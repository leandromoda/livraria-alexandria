, ?, ?, ?, ?, ?, ?, ?)\\n    \\\"\\\"\\\", (\\n        livro_id,\\n        data[\\\"titulo\\\"],\\n        data[\\\"autor\\\"],\\n        data[\\\"isbn\\\"],\\n        data[\\\"ano\\\"],\\n        data[\\\"idioma\\\"],\\n        cluster,\\n        data[\\\"fonte\\\"],\\n        now,\\n        now\\n    ))\\n\\n    conn.commit()\\n    conn.close()\\n\\n    return True\\n\\n\\n# ============================================\\n# FETCHERS\\n# ============================================\\n\\ndef fetch_openlibrary(query, idioma, limit=20):\\n\\n    beat()\\n\\n    try:\\n        res = requests.get(\\n            OPENLIBRARY_URL,\\n            params={\\n                \\\"q\\\": query,\\n                \\\"language\\\": idioma,\\n                \\\"limit\\\": limit\\n            },\\n            timeout=20\\n        )\\n\\n        docs = res.json().get(\\\"docs\\\", [])\\n\\n        books = []\\n\\n        for d in docs:\\n\\n            titulo = d.get(\\\"title\\\")\\n            autores = \\\", \\\".join(d.get(\\\"author_name\\\", []))\\n\\n            isbn_list = d.get(\\\"isbn\\\", [])\\n            isbn = isbn_list[0] if isbn_list else None\\n\\n            ano = d.get(\\\"first_publish_year\\\")\\n\\n            if not titulo:\\n                continue\\n\\n            books.append({\\n                \\\"titulo\\\": titulo,\\n                \\\"autor\\\": autores,\\n                \\\"isbn\\\": isbn,\\n                \\\"ano\\\": ano,\\n                \\\"idioma\\\": idioma,\\n                \\\"fonte\\\": \\\"openlibrary\\\"\\n            })\\n\\n        return books\\n\\n    except Exception as e:\\n        print(f\\\"[{ts()}] ERRO OL → {e}\\\")\\n        return []\\n\\n\\ndef fetch_google(query, idioma, limit=20):\\n\\n    beat()\\n\\n    try:\\n        res = requests.get(\\n            GOOGLE_BOOKS_URL,\\n            params={\\n                \\\"q\\\": query,\\n                \\\"maxResults\\\": limit,\\n                \\\"langRestrict\\\": idioma\\n            },\\n            timeout=20\\n        )\\n\\n        items = res.json().get(\\\"items\\\", [])\\n\\n        books = []\\n\\n        for item in items:\\n\\n            info = item.get(\\\"volumeInfo\\\", {})\\n\\n            titulo = info.get(\\\"title\\\")\\n            autores = \\\", \\\".join(info.get(\\\"authors\\\", []))\\n\\n            industry = info.get(\\\"industryIdentifiers\\\", [])\\n\\n            isbn = None\\n            for i in industry:\\n                if \\\"ISBN\\\" in i[\\\"type\\\"]:\\n                    isbn = i[\\\"identifier\\\"]\\n                    break\\n\\n            ano = info.get(\\\"publishedDate\\\", \\\"\\\")[:4]\\n\\n            if not titulo:\\n                continue\\n\\n            books.append({\\n                \\\"titulo\\\": titulo,\\n                \\\"autor\\\": autores,\\n                \\\"isbn\\\": isbn,\\n                \\\"ano\\\": ano,\\n                \\\"idioma\\\": idioma,\\n                \\\"fonte\\\": \\\"google\\\"\\n            })\\n\\n        return books\\n\\n    except Exception as e:\\n        print(f\\\"[{ts()}] ERRO GOOGLE → {e}\\\")\\n        return []\\n\\n\\n# ============================================\\n# RUN\\n# ============================================\\n\\ndef run(idioma, pacote):\\n\\n    ensure_schema()\\n\\n    inseridos = 0\\n\\n    for cluster, queries in CLUSTERS.items():\\n\\n        print(f\\\"[{ts()}] CLUSTER → {cluster}\\\")\\n\\n        for query in queries:\\n\\n            if inseridos >= pacote:\\n                print(f\\\"[{ts()}] Pacote atingido — STOP.\\\")\\n                return\\n\\n            print(f\\\"[{ts()}] QUERY → {query}\\\")\\n\\n            ol_books = fetch_openlibrary(query, idioma)\\n            g_books = fetch_google(query, idioma)\\n\\n            for book in ol_books + g_books:\\n\\n                if inseridos >= pacote:\\n                    print(f\\\"[{ts()}] Pacote atingido — STOP.\\\")\\n                    return\\n\\n                if insert_book(book, cluster):\\n                    inseridos += 1\\n                    print(\\n                        f\\\"[{ts()}] INSERT {inseridos}/{pacote} → {book['titulo']}\\\"\\n                    )\\n\\n    print(f\\\"[{ts()}] Fim da prospecção.\\\")\\n\\n\\n# ============================================\\n# ENTRYPOINT\\n# ============================================\\n\\nif __name__ == \\\"__main__\\\":\\n    run(\\\"pt\\\", 10)\\n\",\n    \"scripts\\\\steps\\\\publish.py\": \"import requests\\nimport uuid\\nfrom datetime import datetime\\n\\nfrom core.db import get_conn\\nfrom core.logger import log\\n\\n# =========================\\n# CONFIG\\n# =========================\\n\\nSUPABASE_URL = \\\"https://ncnexkuiiuzwujqurtsa.supabase.co\\\"\\nSUPABASE_KEY = \\\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5jbmV4a3VpaXV6d3VqcXVydHNhIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2OTU0MTY2MCwiZXhwIjoyMDg1MTE3NjYwfQ.CacLDlVd0noDzcuVJnxjx3eMr7SjI_19rAsDZeQh6S8\\\"\\n\\nHEADERS = {\\n    \\\"apikey\\\": SUPABASE_KEY,\\n    \\\"Authorization\\\": f\\\"Bearer {SUPABASE_KEY}\\\",\\n    \\\"Content-Type\\\": \\\"application/json\\\",\\n    \\\"Prefer\\\": \\\"resolution=merge-duplicates\\\"\\n}\\n\\nTABLE_URL = f\\\"{SUPABASE_URL}/rest/v1/livros\\\"\\n\\n\\n# =========================\\n# FETCH\\n# =========================\\n\\ndef fetch_pending(limit):\\n\\n    conn = get_conn()\\n    cur = conn.cursor()\\n\\n    cur.execute(\\\"\\\"\\\"\\n        SELECT\\n            titulo,\\n            slug,\\n            autor,\\n            descricao,\\n            isbn,\\n            ano_publicacao,\\n            imagem_url,\\n            id\\n        FROM livros\\n        WHERE status_publish = 0\\n        AND status_review = 1\\n        LIMIT ?\\n    \\\"\\\"\\\", (limit,))\\n\\n    rows = cur.fetchall()\\n    conn.close()\\n\\n    return rows\\n\\n\\n# =========================\\n# PAYLOAD\\n# =========================\\n\\ndef build_payload(row):\\n\\n    now = datetime.utcnow().isoformat()\\n\\n    return {\\n        \\\"id\\\": str(uuid.uuid4()),   # ← UUID válido\\n        \\\"titulo\\\": row[0],\\n        \\\"slug\\\": row[1],\\n        \\\"autor\\\": row[2],\\n        \\\"descricao\\\": row[3],\\n        \\\"isbn\\\": row[4],\\n        \\\"ano_publicacao\\\": row[5],\\n        \\\"imagem_url\\\": row[6],\\n        \\\"created_at\\\": now,\\n        \\\"updated_at\\\": now,\\n    }\\n\\n\\n# =========================\\n# UPSERT\\n# =========================\\n\\ndef upsert_book(payload):\\n\\n    res = requests.post(\\n        TABLE_URL,\\n        headers=HEADERS,\\n        json=payload\\n    )\\n\\n    if res.status_code not in [200, 201]:\\n        print(\\\"STATUS:\\\", res.status_code)\\n        print(\\\"BODY:\\\", res.text)\\n\\n    return res.status_code in [200, 201]\\n\\n\\n# =========================\\n# FLAG\\n# =========================\\n\\ndef mark_published(local_id):\\n\\n    conn = get_conn()\\n    cur = conn.cursor()\\n\\n    cur.execute(\\\"\\\"\\\"\\n        UPDATE livros\\n        SET\\n            status_publish = 1,\\n            updated_at = CURRENT_TIMESTAMP\\n        WHERE id = ?\\n    \\\"\\\"\\\", (local_id,))\\n\\n    conn.commit()\\n    conn.close()\\n\\n\\n# =========================\\n# RUN\\n# =========================\\n\\ndef run(pacote=10):\\n\\n    rows = fetch_pending(pacote)\\n\\n    if not rows:\\n        log(\\\"Nada pendente para publicação.\\\")\\n        return\\n\\n    inserted = 0\\n    failed = 0\\n\\n    for row in rows:\\n\\n        payload = build_payload(row)\\n\\n        ok = upsert_book(payload)\\n\\n        if not ok:\\n            failed += 1\\n            log(f\\\"FALHA → {row[0]}\\\")\\n            continue\\n\\n        mark_published(row[7])\\n\\n        inserted += 1\\n        log(f\\\"PUBLICADO → {row[0]}\\\")\\n\\n    log(\\n        f\\\"PUBLICAÇÃO CONCLUÍDA → {inserted} | falhas {failed}\\\"\\n    )\\n\",\n    \"scripts\\\\steps\\\\review.py\": \"import requests\\nimport re\\nimport unicodedata\\nimport time\\n\\nfrom core.db import get_conn\\nfrom core.logger import log\\n\\n# =========================\\n# CONFIG\\n# =========================\\n\\nOLLAMA_URL = \\\"http://localhost:11434/api/generate\\\"\\nMODEL = \\\"phi3:mini\\\"\\n\\nTIMEOUT = 300\\nMAX_RETRIES = 3\\n\\n\\n# =========================\\n# PROMPT\\n# =========================\\n\\ndef build_prompt(texto):\\n\\n    return f\\\"\\\"\\\"\\nRevise a sinopse abaixo.\\n\\nObjetivos:\\n\\n- Corrigir gramática\\n- Corrigir concordância\\n- Melhorar fluidez\\n- Remover repetições\\n- Máx 80 palavras\\n- Não adicionar conteúdo novo\\n\\nSinopse:\\n\\n{texto}\\n\\\"\\\"\\\"\\n\\n\\n# =========================\\n# LLM CALL\\n# =========================\\n\\ndef review_text(texto):\\n\\n    for attempt in range(MAX_RETRIES):\\n\\n        try:\\n\\n            res = requests.post(\\n                OLLAMA_URL,\\n                json={\\n                    \\\"model\\\": MODEL,\\n                    \\\"prompt\\\": build_prompt(texto),\\n                    \\\"stream\\\": False,\\n                    \\\"options\\\": {\\n                        \\\"temperature\\\": 0.2,\\n                        \\\"num_predict\\\": 180\\n                    }\\n                },\\n                timeout=TIMEOUT\\n            )\\n\\n            text = res.json()[\\\"response\\\"].strip()\\n\\n            if len(text) > 30:\\n                return text\\n\\n        except Exception:\\n            log(f\\\"Retry Review ({attempt+1})\\\")\\n            time.sleep(2)\\n\\n    return None\\n\\n\\n# =========================\\n# SLUG\\n# =========================\\n\\ndef base_slug(text):\\n\\n    text = unicodedata.normalize(\\\"NFKD\\\", text)\\n    text = text.encode(\\\"ascii\\\", \\\"ignore\\\").decode(\\\"ascii\\\")\\n    text = text.lower()\\n\\n    text = re.sub(r\\\"[^a-z0-9\\\\s-]\\\", \\\"\\\", text)\\n    text = re.sub(r\\\"\\\\s+\\\", \\\"-\\\", text)\\n\\n    return text.strip(\\\"-\\\")\\n\\n\\ndef slug_exists(slug, book_id):\\n\\n    conn = get_conn()\\n    cur = conn.cursor()\\n\\n    cur.execute(\\\"\\\"\\\"\\n        SELECT 1\\n        FROM livros\\n        WHERE slug = ?\\n        AND id != ?\\n        LIMIT 1\\n    \\\"\\\"\\\", (slug, book_id))\\n\\n    exists = cur.fetchone() is not None\\n    conn.close()\\n\\n    return exists\\n\\n\\ndef revise_slug(titulo, book_id):\\n\\n    base = base_slug(titulo)\\n    slug = base\\n    counter = 2\\n\\n    while slug_exists(slug, book_id):\\n        slug = f\\\"{base}-{counter}\\\"\\n        counter += 1\\n\\n    return slug\\n\\n\\n# =========================\\n# FETCH PENDENTES\\n# =========================\\n\\ndef fetch_pending(limit):\\n\\n    conn = get_conn()\\n    cur = conn.cursor()\\n\\n    cur.execute(\\\"\\\"\\\"\\n        SELECT id, titulo, descricao\\n        FROM livros\\n        WHERE status_synopsis = 1\\n        AND status_review = 0\\n        LIMIT ?\\n    \\\"\\\"\\\", (limit,))\\n\\n    rows = cur.fetchall()\\n    conn.close()\\n\\n    return rows\\n\\n\\n# =========================\\n# UPDATE\\n# =========================\\n\\ndef update_review(book_id, texto, slug):\\n\\n    conn = get_conn()\\n    cur = conn.cursor()\\n\\n    cur.execute(\\\"\\\"\\\"\\n        UPDATE livros\\n        SET\\n            descricao = ?,\\n            slug = ?,\\n            status_review = 1,\\n            updated_at = CURRENT_TIMESTAMP\\n        WHERE id = ?\\n    \\\"\\\"\\\", (texto, slug, book_id))\\n\\n    conn.commit()\\n    conn.close()\\n\\n\\n# =========================\\n# RUN\\n# =========================\\n\\ndef run(pacote=10):\\n\\n    rows = fetch_pending(pacote)\\n\\n    if not rows:\\n        log(\\\"Nada pendente para revisão.\\\")\\n        return\\n\\n    processed = 0\\n    failed = 0\\n\\n    for book_id, titulo, descricao in rows:\\n\\n        log(f\\\"REVISANDO → {titulo}\\\")\\n\\n        texto_revisto = review_text(descricao)\\n\\n        if not texto_revisto:\\n            failed += 1\\n            log(f\\\"FALHA REVIEW → {titulo}\\\")\\n            continue\\n\\n        slug_revisto = revise_slug(titulo, book_id)\\n\\n        update_review(\\n            book_id,\\n            texto_revisto,\\n            slug_revisto\\n        )\\n\\n        processed += 1\\n\\n        log(f\\\"REVISADO → {titulo}\\\")\\n\\n    log(\\n        f\\\"REVISÃO CONCLUÍDA → {processed} | falhas {failed}\\\"\\n    )\\n\",\n    \"scripts\\\\steps\\\\slugify.py\": \"import re\\nimport unicodedata\\nimport os\\nimport sqlite3\\n\\nfrom datetime import datetime\\n\\n\\n# =========================\\n# DB PATH (ALINHADO PROSPECT)\\n# =========================\\n\\nDB_PATH = os.path.join(\\n    os.path.dirname(__file__),\\n    \\\"..\\\",\\n    \\\"data\\\",\\n    \\\"books.db\\\"\\n)\\n\\n\\ndef get_conn():\\n    return sqlite3.connect(DB_PATH)\\n\\n\\n# =========================\\n# LOGGER SIMPLES\\n# =========================\\n\\ndef log(msg):\\n    now = datetime.now().strftime(\\\"%H:%M:%S\\\")\\n    print(f\\\"[{now}] {msg}\\\")\\n\\n\\n# =========================\\n# SLUG BASE\\n# =========================\\n\\ndef base_slug(text):\\n\\n    text = unicodedata.normalize(\\\"NFKD\\\", text)\\n    text = text.encode(\\\"ascii\\\", \\\"ignore\\\").decode(\\\"ascii\\\")\\n    text = text.lower()\\n\\n    text = re.sub(r\\\"[^a-z0-9\\\\s-]\\\", \\\"\\\", text)\\n    text = re.sub(r\\\"\\\\s+\\\", \\\"-\\\", text)\\n\\n    return text.strip(\\\"-\\\")\\n\\n\\n# =========================\\n# CHECK COLISÃO\\n# =========================\\n\\ndef slug_exists(slug):\\n\\n    conn = get_conn()\\n    cur = conn.cursor()\\n\\n    cur.execute(\\n        \\\"SELECT 1 FROM livros WHERE slug = ? LIMIT 1\\\",\\n        (slug,)\\n    )\\n\\n    exists = cur.fetchone() is not None\\n\\n    conn.close()\\n\\n    return exists\\n\\n\\ndef generate_unique_slug(titulo):\\n\\n    base = base_slug(titulo)\\n\\n    slug = base\\n    counter = 2\\n\\n    while slug_exists(slug):\\n        slug = f\\\"{base}-{counter}\\\"\\n        counter += 1\\n\\n    return slug\\n\\n\\n# =========================\\n# FETCH PENDENTES\\n# =========================\\n\\ndef fetch_pending(limit):\\n\\n    conn = get_conn()\\n    cur = conn.cursor()\\n\\n    cur.execute(\\\"\\\"\\\"\\n        SELECT id, titulo\\n        FROM livros\\n        WHERE status_slug = 0\\n        LIMIT ?\\n    \\\"\\\"\\\", (limit,))\\n\\n    rows = cur.fetchall()\\n    conn.close()\\n\\n    return rows\\n\\n\\n# =========================\\n# UPDATE\\n# =========================\\n\\ndef update_slug(book_id, slug):\\n\\n    conn = get_conn()\\n    cur = conn.cursor()\\n\\n    now = datetime.utcnow()\\n\\n    cur.execute(\\\"\\\"\\\"\\n        UPDATE livros\\n        SET slug = ?,\\n            status_slug = 1,\\n            updated_at = ?\\n        WHERE id = ?\\n    \\\"\\\"\\\", (slug, now, book_id))\\n\\n    conn.commit()\\n    conn.close()\\n\\n\\n# =========================\\n# RUN\\n# =========================\\n\\ndef run(pacote=10):\\n\\n    rows = fetch_pending(pacote)\\n\\n    if not rows:\\n        log(\\\"Nada pendente para slug.\\\")\\n        return\\n\\n    processed = 0\\n\\n    for book_id, titulo in rows:\\n\\n        slug = generate_unique_slug(titulo)\\n\\n        update_slug(book_id, slug)\\n\\n        processed += 1\\n\\n        log(f\\\"SLUG → {titulo} → {slug}\\\")\\n\\n    log(f\\\"SLUG CONCLUÍDO → {processed}\\\")\\n\",\n    \"scripts\\\\steps\\\\synopsis.py\": \"import requests\\nimport time\\nimport os\\nimport sqlite3\\n\\nfrom datetime import datetime\\n\\n\\n# =========================\\n# DB PATH\\n# =========================\\n\\nDB_PATH = os.path.join(\\n    os.path.dirname(__file__),\\n    \\\"..\\\",\\n    \\\"data\\\",\\n    \\\"books.db\\\"\\n)\\n\\n\\ndef get_conn():\\n    return sqlite3.connect(DB_PATH, ",
    "state\\backup\\2026-02-15_08-51_pipeline_full_part_003.json": "timeout=30)\\n\\n\\ndef log(msg):\\n    now = datetime.now().strftime(\\\"%H:%M:%S\\\")\\n    print(f\\\"[{now}] {msg}\\\")\\n\\n\\n# =========================\\n# CONFIG\\n# =========================\\n\\nOLLAMA_URL = \\\"http://localhost:11434/api/generate\\\"\\nMODEL = \\\"phi3:mini\\\"\\n\\nMAX_RETRIES = 3\\n\\n\\n# =========================\\n# PROMPT\\n# =========================\\n\\ndef build_prompt(titulo, autor):\\n\\n    autor = autor or \\\"Autor não informado\\\"\\n\\n    return f\\\"\\\"\\\"\\nEscreva uma sinopse editorial curta (até 80 palavras)\\npara página de recomendação de livros.\\n\\nTom: informativo + persuasivo\\nFoco: valor do livro para o leitor\\nSem spoilers\\nSem citações\\n\\nLivro: {titulo}\\nAutor: {autor}\\n\\\"\\\"\\\"\\n\\n\\n# =========================\\n# LLM CALL\\n# =========================\\n\\ndef generate_synopsis(titulo, autor):\\n\\n    prompt = build_prompt(titulo, autor)\\n\\n    for attempt in range(MAX_RETRIES):\\n\\n        try:\\n\\n            res = requests.post(\\n                OLLAMA_URL,\\n                json={\\n                    \\\"model\\\": MODEL,\\n                    \\\"prompt\\\": prompt,\\n                    \\\"stream\\\": False,\\n                    \\\"options\\\": {\\n                        \\\"temperature\\\": 0.4,\\n                        \\\"num_predict\\\": 180\\n                    }\\n                },\\n                timeout=120\\n            )\\n\\n            text = res.json()[\\\"response\\\"].strip()\\n\\n            if len(text) > 30:\\n                return text\\n\\n        except Exception:\\n            log(f\\\"Retry LLM ({attempt+1}) → {titulo}\\\")\\n            time.sleep(2)\\n\\n    return None\\n\\n\\n# =========================\\n# FETCH PENDENTES\\n# =========================\\n\\ndef fetch_pending(limit):\\n\\n    conn = get_conn()\\n    cur = conn.cursor()\\n\\n    cur.execute(\\\"\\\"\\\"\\n        SELECT id, titulo, autor\\n        FROM livros\\n        WHERE status_synopsis = 0\\n        LIMIT ?\\n    \\\"\\\"\\\", (limit,))\\n\\n    rows = cur.fetchall()\\n    conn.close()\\n\\n    return rows\\n\\n\\n# =========================\\n# UPDATE\\n# =========================\\n\\ndef update_synopsis(book_id, text):\\n\\n    conn = get_conn()\\n    cur = conn.cursor()\\n\\n    cur.execute(\\\"\\\"\\\"\\n        UPDATE livros\\n        SET\\n            descricao = ?,\\n            status_synopsis = 1,\\n            updated_at = ?\\n        WHERE id = ?\\n    \\\"\\\"\\\", (\\n        text,\\n        datetime.utcnow(),\\n        book_id\\n    ))\\n\\n    conn.commit()\\n    conn.close()\\n\\n\\n# =========================\\n# RUN\\n# =========================\\n\\ndef run(pacote=10):\\n\\n    rows = fetch_pending(pacote)\\n\\n    if not rows:\\n        log(\\\"Nada pendente para sinopse.\\\")\\n        return\\n\\n    processed = 0\\n    failed = 0\\n\\n    for book_id, titulo, autor in rows:\\n\\n        log(f\\\"LLM → {titulo}\\\")\\n\\n        synopsis = generate_synopsis(titulo, autor)\\n\\n        if not synopsis:\\n            failed += 1\\n            log(f\\\"FALHA → {titulo}\\\")\\n            continue\\n\\n        update_synopsis(book_id, synopsis)\\n\\n        processed += 1\\n        log(f\\\"SINOPSE OK → {titulo}\\\")\\n\\n    log(\\n        f\\\"SINOPSE CONCLUÍDO → {processed} | falhas {failed}\\\"\\n    )\\n\",\n    \"scripts\\\\steps\\\\_clusters.py\": \"# ============================================\\n# LIVRARIA ALEXANDRIA — CLUSTERS EDITORIAIS\\n# Classificação bibliográfica expandida\\n# ============================================\\n\\nCLUSTERS = {\\n\\n    # ========================================\\n    # ECONOMIA & FINANÇAS\\n    # ========================================\\n\\n    \\\"economics\\\": [\\n        \\\"economics\\\",\\n        \\\"political economy\\\",\\n        \\\"macroeconomics\\\",\\n        \\\"microeconomics\\\",\\n        \\\"international economics\\\",\\n        \\\"economic policy\\\",\\n        \\\"development economics\\\",\\n        \\\"public economics\\\",\\n        \\\"monetary economics\\\",\\n        \\\"economic history\\\"\\n    ],\\n\\n    \\\"finance\\\": [\\n        \\\"finance\\\",\\n        \\\"corporate finance\\\",\\n        \\\"public finance\\\",\\n        \\\"financial markets\\\",\\n        \\\"financial management\\\",\\n        \\\"financial risk management\\\",\\n        \\\"behavioral finance\\\",\\n        \\\"investment banking\\\",\\n        \\\"financial regulation\\\",\\n        \\\"capital markets\\\"\\n    ],\\n\\n    \\\"investments\\\": [\\n        \\\"investing\\\",\\n        \\\"investment analysis\\\",\\n        \\\"portfolio management\\\",\\n        \\\"value investing\\\",\\n        \\\"stock market\\\",\\n        \\\"equity investing\\\",\\n        \\\"wealth management\\\",\\n        \\\"asset allocation\\\",\\n        \\\"hedge funds\\\",\\n        \\\"private equity\\\"\\n    ],\\n\\n    \\\"personal_finance\\\": [\\n        \\\"personal finance\\\",\\n        \\\"financial planning\\\",\\n        \\\"wealth building\\\",\\n        \\\"retirement planning\\\",\\n        \\\"financial independence\\\",\\n        \\\"money management\\\",\\n        \\\"budgeting\\\",\\n        \\\"debt management\\\",\\n        \\\"financial literacy\\\",\\n        \\\"passive income\\\"\\n    ],\\n\\n    # ========================================\\n    # NEGÓCIOS & GESTÃO\\n    # ========================================\\n\\n    \\\"business\\\": [\\n        \\\"business\\\",\\n        \\\"business administration\\\",\\n        \\\"business management\\\",\\n        \\\"international business\\\",\\n        \\\"family business\\\",\\n        \\\"small business\\\",\\n        \\\"business operations\\\",\\n        \\\"business models\\\",\\n        \\\"corporate governance\\\",\\n        \\\"business ethics\\\"\\n    ],\\n\\n    \\\"strategy\\\": [\\n        \\\"business strategy\\\",\\n        \\\"corporate strategy\\\",\\n        \\\"competitive strategy\\\",\\n        \\\"strategic planning\\\",\\n        \\\"strategic management\\\",\\n        \\\"military strategy\\\",\\n        \\\"innovation strategy\\\",\\n        \\\"growth strategy\\\",\\n        \\\"market strategy\\\",\\n        \\\"platform strategy\\\"\\n    ],\\n\\n    \\\"management\\\": [\\n        \\\"management\\\",\\n        \\\"organizational management\\\",\\n        \\\"operations management\\\",\\n        \\\"project management\\\",\\n        \\\"change management\\\",\\n        \\\"performance management\\\",\\n        \\\"risk management\\\",\\n        \\\"quality management\\\",\\n        \\\"process management\\\",\\n        \\\"lean management\\\"\\n    ],\\n\\n    \\\"leadership\\\": [\\n        \\\"leadership\\\",\\n        \\\"executive leadership\\\",\\n        \\\"transformational leadership\\\",\\n        \\\"servant leadership\\\",\\n        \\\"organizational leadership\\\",\\n        \\\"team leadership\\\",\\n        \\\"strategic leadership\\\",\\n        \\\"leadership development\\\",\\n        \\\"decision leadership\\\",\\n        \\\"crisis leadership\\\"\\n    ],\\n\\n    # ========================================\\n    # EMPREENDEDORISMO\\n    # ========================================\\n\\n    \\\"entrepreneurship\\\": [\\n        \\\"entrepreneurship\\\",\\n        \\\"startups\\\",\\n        \\\"venture capital\\\",\\n        \\\"innovation management\\\",\\n        \\\"business innovation\\\",\\n        \\\"founder mindset\\\",\\n        \\\"startup strategy\\\",\\n        \\\"scaling startups\\\",\\n        \\\"product-market fit\\\",\\n        \\\"entrepreneurial finance\\\"\\n    ],\\n\\n    \\\"innovation\\\": [\\n        \\\"innovation\\\",\\n        \\\"disruptive innovation\\\",\\n        \\\"technology innovation\\\",\\n        \\\"innovation ecosystems\\\",\\n        \\\"innovation strategy\\\",\\n        \\\"product innovation\\\",\\n        \\\"design thinking\\\",\\n        \\\"business experimentation\\\",\\n        \\\"innovation leadership\\\",\\n        \\\"digital transformation\\\"\\n    ],\\n\\n    # ========================================\\n    # DECISÃO & COMPORTAMENTO\\n    # ========================================\\n\\n    \\\"decision_making\\\": [\\n        \\\"decision making\\\",\\n        \\\"managerial decision making\\\",\\n        \\\"strategic decision making\\\",\\n        \\\"decision analysis\\\",\\n        \\\"decision theory\\\",\\n        \\\"decision science\\\",\\n        \\\"complex decision making\\\",\\n        \\\"data driven decision making\\\",\\n        \\\"risk decision making\\\",\\n        \\\"executive decisions\\\"\\n    ],\\n\\n    \\\"behavioral_economics\\\": [\\n        \\\"behavioral economics\\\",\\n        \\\"behavioral finance\\\",\\n        \\\"economic psychology\\\",\\n        \\\"choice architecture\\\",\\n        \\\"bounded rationality\\\",\\n        \\\"prospect theory\\\",\\n        \\\"nudging\\\",\\n 